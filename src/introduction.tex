% !TEX root = thesis.tex
\chapter{Introduction}
\label{chap:introduction}


\section{Motivation}
\label{sec:introduction_motivation}
A large branch of \gls{se} is software testing and quality assurance. In 2002 a survey showed inadequate software testing cost the United States about \$59.5 billion~\cite{RTI02}. It is imperative for research and development to continue in this area to optimize the effectiveness and efficiency of software testing and quality assurance in \gls{se}.

The core artifacts of software development are the source code and the test suite. The source code artifact is composed of many source code units (i.e., methods, classes and, functions) while the test suite is composed of many test code units (i.e., test cases and unit tests). As software projects mature over-time their artifacts change based on the amount of development being done. Software developers have many software testing methodologies and approach at their disposal to test the source code. An essential core of software testing \emph{unit testing} which is a white-box testing technique that tests source code units to ensure they behave correctly according to the test code units.

How does a develop know that their test suite is effective? An effective test suite is ``one that is capable of detecting all real bugs''~\cite{Wey93}. As we know the purpose of a test suite is to detect if there are any software bugs in the source code. Several techniques exist that measure statement/branch/path coverage of the source code being exercised by the test suite~\cite{ZHM97}. These coverage techniques allow developers to see source code units are being tested according to type of coverage criteria. The acquire coverage of the source code might not be an adequate indicator of test suite effectiveness depending on the technique used~\cite{NA09,GJ08}.

One approach to determine the effectiveness of a test suite is to use \emph{mutation testing}. Mutation testing uses a set of \emph{mutation operators} to generate faulty versions of a software system's source code called \emph{mutants}. Mutation operators are created based on an existing fault taxonomy and each operator usually corresponds to a specific type of fault. Andrews et al. showed that mutants potentially could be used as substitutes for real faults~\cite{ABLN06}. A test suite is evaluated against a set of mutants to determine the \emph{mutation score}. The mutation score is defined as the percentage of non-equivalent mutants that are detected (\emph{killed}) by a test suite. The better a test suite, the more mutants will be killed and thus the higher the mutation score.

A major drawback of mutation testing is that even a small software system may yield hundreds or thousands of mutants -- potentially making the process cost prohibitive in comparison to other coverage metrics.


\section{Problem}
\label{sec:introduction_problem}
Mutation testing is offers a highly effective approach for determining the effectiveness of a test suite at high cost. The adoption of mutation testing in practice has been slow due to the performance issues~\cite{?}. Three approaches have been proposed to improve mutation testing performance and scalability~\cite{OU00}:

\begin{enumerate}
  \item \textbf{``Do fewer'' approach:} this category of optimizations aim to decrease the computational cost of mutation testing by reducing the number of mutants that a test suite is evaluated against. The most popular example from this category is selective mutation -- the use of a subset of mutation operators that have been empirically shown to be as effective as using an entire set of operators~\cite{OLR+96}.

  \item \textbf{``Do smarter'' approach:} this category of optimizations aim to decrease the cost of mutation testing by improving the actual mutation testing technique. For example, weak mutation \emph{``...is an approximation technique that compares the internal states of mutant and original program immediately after execution of the mutated portion of the code (instead of comparing the program output)''}~\cite{OU00}.

  \item \textbf{``Do faster'' approach:} this category of optimizations aim to reduce the cost of mutation testing by focusing on performance. For example, one ``do faster'' approach improves compilation time using schema-based mutation -- \emph{``...encodes all mutations into one source level program...''}~\cite{OU00}.
\end{enumerate}

As an alternative to the above approaches, we propose a ``do fewer and smarter'' technique for mutation testing at the unit level. When mutation testing is used for the creation or improvement of a test suite, the test suite will often have to be applied to the mutants in an iterative fashion as tests are added, removed and modified. Furthermore, the effects on the mutation score after each iteration have to be observed. We propose to replace at least some of the mutation testing of intermediate tests with mutation score prediction and thus decrease the number of mutants that have to be evaluated using a test suite. Our proposed approach uses machine learning to predict the mutation score based on a combination of source code and test suite metrics of the code unit under test.


\section{Thesis Statement and Scope of Research}
\label{sec:introduction_statement_and_scope}
\begin{quote}
  \emph{\textbf{Thesis Statement:} Using source code and test suite metrics in combination with machine learning techniques we can accurately predict mutation testing scores. The predictions can be used to reduce the resource cost of mutation testing in traditional iterative development.}
\end{quote}

Essentially, this thesis presents an approach that predict the mutation scores of source code units. This approach is ideal for the creation or improvement of a test suite as it mitigates the amount of time spent on mutation testing while developers work in an iterative fashion.

The scope of this thesis is limited to open-source Java programs that contain a test suite. The reason is that mutation testing research of Java programs is fairly mature and contains a number of tools~\cite{JH10}.


\section{Contributions}
\label{sec:introduction_contributions}
This thesis adds the following as contributions to the field of mutation testing, software testing and software quality assurance:

\begin{itemize}
  \item An approach to predict the mutation scores of software systems using machine learning techniques.
  \item An empirical evaluation of the accuracy of the developed approach in respect to mutation score prediction.
  \item A study that explores the generalizable of mutation score prediction across different software systems.
  \item A statistical analysis of various source code and test suite metrics of software systems their correlation with each other and mutation score.
  % \item The effect of source code and test suite changes in relation to mutation scores.
\end{itemize}


\section{Organization of Thesis}
\label{sec:introduction_organization}
We just outlined our motivation and problem for this thesis. The thesis statement is declared along with the contributions of this research. The rest of this thesis is organized as follows:

\begin{itemize}
  \item \emph{Chapter~\ref{chap:background}:} we describe machine learning techniques, mutation testing and software metrics.
  \item \emph{Chapter~\ref{chap:approach}:} we describe our overall approach to mutation score prediction, our selected tools and, related work.
  \item \emph{Chapter~\ref{chap:experiment}:} we describe our experimental setup and results of applying our approach to open source projects.
  % \item \emph{Chapter~\ref{chap:analysis}:} we analyze our results and discuss our findings.
  % \item \emph{Chapter~\ref{chap:case-study}:} we present a case study to explore the effects of source code and test suite changes in relation to mutation scores.
  \item \emph{Chapter~\ref{chap:conclusions}:} we summarize the research accomplish, future work, limitations, and contributions.
\end{itemize}
