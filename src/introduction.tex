% !TEX root = thesis.tex
\chapter{Introduction}
\label{chap:introduction}


\section{Motivation}
\label{sec:introduction_motivation}
A large branch of \gls{se} is software testing and verification. In 2002 a survey showed inadequate software testing cost the United States about \$59.5 billion~\cite{RTI02}. This indicates a continued need to continue in this area to optimize the effectiveness and efficiency of software testing and verification in \gls{se}.

From a software testing perspective, the core artifacts of software development are the source code and the test suite. The source code is composed of many source code units (i.e., methods, classes, functions) while the test suite is composed of many test code units (i.e., test cases and unit tests). As software projects mature over-time these artifacts evolve. For example, during maintenance developers fix faults reported by users and the fix to these faults might reside within a particular method which is changed to resolve the bug. It is also possible that during development a new feature is added to an existing module within the software system, the accompanying tests must also be updated to ensure that the new feature is tested. Software developers have a number of software testing methodologies and approach at their disposal to verify the source code. An essential aspect of most software testing methodologies is \emph{unit testing}, a white-box testing technique that evaluates source code units to ensure they behave correctly when test code units are applied.

A major challenge is the assessment of test suites and determining if a given test suite is effective. An effective test suite is \emph{``\ldots one that is capable of detecting all real bugs''}~\cite{Wey93} and the purpose of a test suite is to increase confidence that out source code functions correctly. Several techniques exist that measure code coverage (e.g., branch, statement, path) being exercised by a test suite~\cite{ZHM97}. These code coverage techniques allow developers to assess that source code units are being tested according to a type of coverage criteria, the coverage of the source code might not be an adequate indicator of test suite effectiveness depending on the technique used~\cite{NA09,GJ08}.

One approach to determine the effectiveness of a test suite is to use \emph{mutation testing} -- a white box coverage technique that assesses the ability of tests to detect \emph{`mutant'} faults. Specifically, mutation testing uses a set of \emph{mutation operators} to generate faulty versions of a software system's source code called \emph{mutants}. Mutation operators are created based on an existing fault taxonomy and each operator usually corresponds to a specific type of fault. Andrews et al. showed that mutants potentially could be used as substitutes for real faults~\cite{ABLN06}. A test suite is evaluated against a set of mutants to determine the \emph{mutation score}. The mutation score is defined as the percentage of non-equivalent mutants that are detected (i.e., \emph{killed}) by a test suite. The better a test suite, the more mutants will be killed and thus the higher the mutation score.

A major drawback of mutation testing is that even a small software system may yield hundreds or thousands of mutants -- potentially making the process cost prohibitive in comparison to other coverage metrics. For example, two open source systems \texttt{jtopas} about 5K total \gls{sloc} and \texttt{xstream} about 30K total \gls{sloc} has 1921 and 10607 possible mutants respectively\cite{SZ09}.


\section{Problem}
\label{sec:introduction_problem}
Mutation testing offers a highly effective approach for determining the effectiveness of a test suite but at high cost. The adoption of mutation testing in industry has been slow due to the performance issues~\cite{?}. Three approaches have been proposed to improve mutation testing performance and scalability~\cite{OU01}:

\begin{enumerate}
  \item \textbf{``Do fewer'' approach:} this category of optimizations aim to decrease the computational cost of mutation testing by reducing the number of mutants that a test suite is evaluated against. The most popular example from this category is selective mutation -- the use of a subset of mutation operators that have been empirically shown to be as effective as using an entire set of operators~\cite{OLR+96}.

  \item \textbf{``Do smarter'' approach:} this category of optimizations aim to decrease the cost of mutation testing by improving the actual mutation testing technique. For example, weak mutation \emph{``\ldots is an approximation technique that compares the internal states of mutant and original program immediately after execution of the mutated portion of the code (instead of comparing the program output)''}~\cite{OU01}.

  \item \textbf{``Do faster'' approach:} this category of optimizations aim to reduce the cost of mutation testing by focusing on performance. For example, one ``do faster'' approach improves compilation time using schema-based mutation -- \emph{``\ldots encodes all mutations into one source level program \ldots''}~\cite{OU01}.
\end{enumerate}

As an alternative to the above approaches, we propose a ``do fewer and smarter'' approach for mutation testing at the unit level. When mutation testing is used for the creation or improvement of a test suite, the test suite will often have to be applied to the mutants in an iterative fashion as tests are added, removed and modified. Furthermore, the effects on the mutation score after each iteration have to be observed. We propose to replace at least some of the mutation testing of intermediate tests with mutation score prediction and thus decrease the number of mutants that have to be evaluated using a test suite. Our proposed approach uses machine learning to predict the mutation score based on a combination of source code and test suite metrics of the code unit under test.


\section{Thesis Statement and Scope of Research}
\label{sec:introduction_statement_and_scope}
\begin{quote}
  \emph{\textbf{Thesis Statement:} The use of source code and test suite metrics in combination with machine learning techniques can accurately predict mutation scores. Furthermore, the predictions can be used to reduce the performance cost of mutation testing when used to iteratively develop test suites.}
\end{quote}

Essentially, this thesis presents an approach that predicts the mutation scores of code units. This approach is ideal for the iterative creation or improvement of a test suite as it mitigates the amount of time spent on mutation testing (i.e., less testing of mutants).

The scope of this thesis is limited to open-source Java programs. We have selected this scope because mutation testing of Java programs is fairly mature and there are a number of existing mutation tools for Java~\cite{JH10}.


\section{Contributions}
\label{sec:introduction_contributions}
This thesis adds the following as contributions to the field of mutation testing, software testing and software quality assurance:

\begin{itemize}
  \item An approach to predict the mutation scores of software systems using machine learning techniques.
  \item An empirical evaluation of the accuracy of the developed approach with respect to mutation score prediction.
  \item A study that explores the generalizable of \gls{svm} (i.e., a supervised machine learning technique) in the context of mutation testing predition across software systems.
\end{itemize}


\section{Organization of Thesis}
\label{sec:introduction_organization}
In this chapter we have outlined our motivation in Section~\ref{sec:introduction_motivation} and problem in Section~\ref{sec:introduction_problem}. We presented our thesis statement in Section~\ref{sec:introduction_statement_and_scope} along with a general set of contributions for this thesis in Section~\ref{sec:introduction_contributions}. The reminding chapters of this thesis is organized as follows:

\begin{itemize}
  \item \emph{Chapter~\ref{chap:background}:} we describe the background material and concepts used in this thesis. We look at uses and details of machine learning on how it can be used for classification problems. We illustrate what mutation testing is and  the advantages and disadvantages of using it. We finally cover software metrics and their uses in understanding software systems and complexity.
  \item \emph{Chapter~\ref{chap:approach}:} we describe our overall approach to mutation score prediction. We cover each step of our approach all while detailing the selected tools used. We discuss related work in the area of predictions using source code metrics.
  \item \emph{Chapter~\ref{chap:experiment}:} we describe our experimental setup as well as our 8 selected experimental subjects. We conduct a number of experiments to evaluate our approach along with discussions.
  \item \emph{Chapter~\ref{chap:conclusions}:} we summarize the thesis and mentioned the contributions. We outline future work as well as limitations on the thesis.
\end{itemize}
