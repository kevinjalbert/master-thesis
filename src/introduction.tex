\chapter{Introduction}
\label{chap:introduction}


\section{Motivation}
\label{sec:introduction_motivation}


\section{Problem}
\label{sec:introduction_problem}
Mutation testing uses a set of \emph{mutation operators} to generate faulty versions of a program called \emph{mutants}. Mutation operators are created based on an existing fault taxonomy and each operator usually corresponds to a specific type of fault. A test suite is evaluated against a set of mutants to determine the \emph{mutation score}. The mutation score is defined as the percentage of non-equivalent mutants that are detected (\emph{killed}) by a test suite. The better a test suite, the more mutants will be killed and thus the higher the mutation score.

A major drawback of mutation testing is that even a small program may yield hundreds or thousands of mutants -- potentially making the process cost prohibitive in comparison to other coverage metrics.


\section{Thesis Statement and Scope of Research}
\label{sec:introduction_statement_and_scope}
Three approaches have been proposed to improve mutation testing performance and scalability~\cite{OU00}:

\begin{enumerate}
  \item \textbf{``Do fewer'' approach:} this category of optimizations aim to decrease the computational cost of mutation testing by reducing the number of mutants that a test suite is evaluated against. The most popular example from this category is selective mutation -- the use of a subset of mutation operators that have been empirically shown to be as effective as using an entire set of operators~\cite{OLR+96}.

  \item \textbf{``Do smarter'' approach:} this category of optimizations aim to decrease the cost of mutation testing by improving the actual mutation testing technique. For example, weak mutation \emph{``...is an approximation technique that compares the internal states of mutant and original program immediately after execution of the mutated portion of the code (instead of comparing the program output)''}~\cite{OU00}.

  \item \textbf{``Do faster'' approach:} this category of optimizations aim to reduce the cost of mutation testing by focusing on performance. For example, one ``do faster'' approach improves compilation time using schema-based mutation -- \emph{``...encodes all mutations into one source level program...''}~\cite{OU00}.
\end{enumerate}

As an alternative to the above approaches, we propose a ``do fewer and smarter'' technique for mutation testing at the unit level.  When mutation testing is used for the creation or improvement of a test suite,  the test suite will often have to be applied to the mutants in an iterative fashion as tests are added, removed and modified. Furthermore, the effects on the mutation score after each iteration have to be observed. We propose to replace at least some of the mutation testing of intermediate tests with mutation score prediction and thus decrease the number of mutants that have to be evaluated using a test suite. Our proposed approach uses machine learning to predict the mutation score based on a combination of source code and test suite metrics of the code unit under test.

\begin{quote}
  \emph{\textbf{Thesis Statement:} Mutation scores can be predicted with reasonable accuracy using source code and test suite metrics to improve the mutation testing performance.}
\end{quote}

The scope of this thesis is limited to open-source Java programs that contain a test suite. Mutation testing research on Java programs is fairly mature and open source Java programs are widely available.


\section{Contributions}
\label{sec:introduction_contributions}
This thesis adds the following as contributions to the field of mutation testing, software testing and software quality assurance:

\begin{itemize}
  \item An approach to predict the mutation scores of open source projects using machine learning techniques.
  \item An empirical evaluation of the accuracy of the developed approach to mutation score prediction.
  \item A study that explores the generalizable of mutation score prediction across project domains.
  \item A statistical analysis of various source code and test suite metrics of open source programs and their correlation with each other.
\end{itemize}


\section{Organization of Thesis}
\label{sec:introduction_organization}
We just outlined our motivation and problem for this thesis. The thesis statement is declared along with the contributions of this research. The rest of this thesis is organized as follows:

\begin{itemize}
  \item \emph{Chapter~\ref{chap:background}:} we describe machine learning techniques,  mutation testing and software metrics.
  \item \emph{Chapter~\ref{chap:approach}:} we describe our overall approach to mutation score prediction.
  \item \emph{Chapter~\ref{chap:experiment}:} we apply our approach to an open source project and discuss the effectiveness of our prediction based on this preliminary evaluation.
  \item \emph{Chapter~\ref{chap:conclusions}:} we summarize the research accomplish, future work, limitations, and contributions.
\end{itemize}
