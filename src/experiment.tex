\chapter{Experiment}
\label{chap:experiment}
In this chapter we discuss the application of our approach from Chapter~\ref{chap:approach} using an experiment. We describe how we setup and conduct our experiment in Section~\ref{sec:experiment_setup}. We describe the selected test subjects using general metrics in Section~\ref{sec:experiment_subjects}. Finally we display our experimental results in Section~\ref{sec:experiment_results}.


\section{Experimental Setup}
\label{sec:experiment_setup}
For our experiment we collect a set of 8 open source software systems to use for both training and prediction. Our selection criteria for our experimental subjects were the following:

\begin{itemize}
  \item An open source Java software system.
  \item Contains a test suite or set of test cases.
  \item Is over 5K total \gls{sloc}.
\end{itemize}

We only wanted to collect software system that have a minimum of 5K total \gls{sloc} to ensure that the our approach would gather a decent amount of data. Open source projects are relatively easy to find and are freely available to analyze. The only firm requirement we desired was the need for a test suite or set of test cases, due to fundamental needs of mutation testing.

We run our approach on a machine that has 6 GB of \gls{ram} and an Intel Core i7-870 processor running at 2.93 GHz. We have configured Javalanche to run with no parallel task execution along with its coverage impact analysis. We avoid task parallelization as it avoids any unnecessary issues that can occur due to concurrent access to file resources that a test suite may use. The coverage impact analysis slows down Javalanche though it provides comprehensive data regarding the mutants, thus allowing use to recalculate the mutation score for different sets of mutation operators easily.

For each test subject we import the project into Eclipse and run the project through a \emph{test} that Javalanche provides. This test indicates any unit test cases that cannot execute properly or fail within Javalanche. We have to remove these test cases as the mutation testing process requires a test suite with no errors. We collect all the results in a database so we can conduct several forms of evaluation.

Using LIBSVM we can calculate the accuracy of the collected data from our test subjects. We allow LIBSVM to use 8 threads for computation tasks. We can evaluate how effective our predict approach is using the following accuracy values:

\begin{itemize}
  \item Cross-validation accuracy of each test subject using itself for training.
  \item Cross-validation accuracy of all test subjects using all data for training.
  \item Prediction accuracy of each test subject using all data for training.
  \item Prediction accuracy of some test subjects using a different test subject's data for training.
\end{itemize}

The first accuracy can provide some insight on how effective the prediction is on intra-project data. The remaining accuracies provide insight on how effective the prediction is on cross-project data. Provided the results of the cross-project data prediction we can better understand if our prediction approach can generalize to some extent.

We then explore aspects of optimizing our approach by observing the correlation of the provided attributes used in our \gls{svm}. We also observe the effect of changing the set of mutation operators and attributes to find their effect on prediction accuracy. Finally we re-conduct the previous experiments regarding the cross-validation and prediction accuracy to validate the effect of our optimizations.


\section{Experimental Subjects}
\label{sec:experiment_subjects}
\begin{table}[!t]
  \centering
  \rowcolors{2}{gray!30}{gray!20}
  \begin{tabular}{|l|r|r|r|}
    \hline
    \rowcolor[RGB]{169,196,223}
    \textbf{Program} & \textbf{SLOC} & \textbf{Test SLOC} & \textbf{Test Cases} \\
    \hline logback-core (1.0.3)~\cite{logback} & 12118 & 8145 & 286 \\
    \hline barbecue (1.5-beta1)~\cite{barbecue} & 4837 & 2910 & 225 \\
    \hline jgap (3.6.1)~\cite{jgap} & 28975 & 19694 & 1355 \\
    \hline commons-lang (3.1)~\cite{commons-lang} & 19499 & 33332 & 2050 \\
    \hline joda-time (2.0)~\cite{joda-time} & 27139 & 51428 & 3866 \\
    \hline openfast (1.1.0)~\cite{openfast} & 11646 & 5587 & 322 \\
    \hline jsoup (1.6.2)~\cite{jsoup} & 10949 & 2883 & 319 \\
    \hline joda-primitives (1.0)~\cite{joda-primitives} & 11157 & 6989 & 1810 \\
    \hline \textbf{TOTAL} & \textbf{126320} & \textbf{130968} & \textbf{10233} \\
    \hline
  \end{tabular}
  \caption{The experimental subjects.}
  \vspace{2mm}
  \hrule
  \label{tab:experimental_subjects}
\end{table}

Following the criteria outlined in Section~\ref{sec:experiment_setup} we selected the following 8 open source Java projects shown in Table~\ref{tab:experimental_subjects}. We provide a brief description of each project:

\begin{itemize}
  \item \textbf{logback-core}: \emph{``Logback is intended as a successor to the popular log4j project, picking up where log4j leaves off. The logback-core module lays the groundwork for the other two modules.''}~\cite{logback}
  \item \textbf{barbecue}: \emph{``Barbecue is an open-source, Java library that provides the means to create barcodes for printing and display in Java applications.''}~\cite{barbecue}
  \item \textbf{jgap}: \emph{``JGAP is a Genetic Algorithms and Genetic Programming component provided as a Java framework.''}~\cite{jgap}
  \item \textbf{commons-lang}: \emph{``The standard Java libraries fail to provide enough methods for manipulation of its core classes. Apache Commons Lang provides these extra methods.''}\cite{commons-lang}
  \item \textbf{joda-time}: \emph{``Joda-Time provides a quality replacement for the Java date and time classes. The design allows for multiple calendar systems, while still providing a simple API.''}~\cite{joda-time}
  \item \textbf{openfast}: \emph{``OpenFAST is a 100\% Java implementation of the FAST Protocol (FIX Adapted for STreaming). The FAST protocol is used to optimize communications in the electronic exchange of financial data.''}~\cite{openfast}
  \item \textbf{jsoup}: \emph{``jsoup is a Java library for working with real-world HTML. It provides a very convenient API for extracting and manipulating data, using the best of DOM, CSS, and jquery-like methods.''}~\cite{jsoup}
  \item \textbf{joda-primitives}: \emph{``Joda Primitives provides collections and utilities to bridge the gap between objects and primitive types in Java.''}~\cite{joda-primitives}
\end{itemize}


\section{Experimental Results}
\label{sec:experiment_results}
